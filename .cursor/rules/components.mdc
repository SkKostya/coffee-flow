---
description: Создание или редактирование компонентов
alwaysApply: false
---

# Coffee Flow Component Rules

## Правила для React компонентов

### Основные принципы

- **ВСЕГДА используйте React Native Elements** для базовых UI компонентов
- Все компоненты должны следовать принципам функционального программирования
- Используйте TypeScript для типизации пропсов и состояния
- Компоненты должны быть переиспользуемыми и настраиваемыми через пропсы
- Следуйте принципу единственной ответственности
- Экранные компоненты размещаются в папке `app/` с группировкой по модулям

### Структура экранов Coffee Flow

#### 1. Организация экранов

```
app/                          # Экранные компоненты (Expo Router)
├── _layout.tsx              # Корневой layout с провайдерами
├── index.tsx                # Главная страница
├── onboarding.tsx           # Онбординг
├── profile.tsx              # Профиль пользователя
├── favorites.tsx            # Избранные кофейни
├── orders.tsx               # История заказов
├── checkout.tsx             # Оформление заказа
├── cart.tsx                 # Корзина
├── menu.tsx                 # Меню кофейни
├── auth/                    # Модуль аутентификации
│   └── login.tsx           # Экран входа
└── coffee-shops/            # Модуль кофеен
    ├── index.tsx            # Список кофеен
    └── [id].tsx             # Детальная страница кофейни
```

#### 2. Правила для экранных компонентов

- Каждый экран должен быть в отдельном файле
- Группируйте связанные экраны в папки по модулям
- Используйте Expo Router для навигации между экранами
- Следуйте принципам responsive дизайна для мобильных и планшетов

### React Native Elements

#### 1. Обязательное использование

- **Button** - используйте `@rneui/themed` Button вместо TouchableOpacity
- **Input** - используйте `@rneui/themed` Input вместо TextInput
- **Card** - используйте `@rneui/themed` Card для карточек
- **SearchBar** - используйте `@rneui/themed` SearchBar для поиска
- **Tab** - используйте `@rneui/themed` Tab для навигации
- **Text** - используйте `@rneui/themed` Text для текста

#### 2. Импорты React Native Elements

```typescript
// ✅ ПРАВИЛЬНО - импорт из @rneui/themed
import { Button, Input, Card, Text, SearchBar, Tab } from '@rneui/themed';

// ❌ НЕПРАВИЛЬНО - импорт из react-native
import { TouchableOpacity, TextInput, View, Text } from 'react-native';
```

#### 3. Настройка компонентов

- Используйте `useCoffeeFlowTheme()` для доступа к теме
- Настраивайте цвета через `color` проп
- Используйте `variant` проп для разных стилей
- Применяйте `size` проп для размеров

```typescript
// ✅ ПРАВИЛЬНО - использование React Native Elements
const Button: React.FC<ButtonProps> = ({ variant = 'primary' }) => {
  const { theme } = useCoffeeFlowTheme();

  return (
    <Button
      type={variant === 'primary' ? 'solid' : 'outline'}
      color="primary"
      title="Нажми меня"
    />
  );
};

// ❌ НЕПРАВИЛЬНО - кастомная реализация
const Button = ({ variant = 'primary' }) => (
  <TouchableOpacity style={customStyles[variant]}>
    <Text>Нажми меня</Text>
  </TouchableOpacity>
);
```

### Структура компонента

#### 1. Стандартная структура

```typescript
import React from 'react';
import { ViewStyle, TextStyle } from 'react-native';
import { Button, Input, Card } from '@rneui/themed';
import { useCoffeeFlowTheme } from '../../shared/theme';
import type { ComponentProps } from '../../types';

interface ButtonProps {
  title: string;
  onPress: () => void;
  variant?: 'primary' | 'secondary';
  disabled?: boolean;
}

const Button: React.FC<ButtonProps> = ({
  title,
  onPress,
  variant = 'primary',
  disabled = false,
}) => {
  const { theme } = useCoffeeFlowTheme();

  // Стили для компонента
  const buttonStyle: ViewStyle = {
    // стили
  };

  return (
    <Button
      title={title}
      onPress={onPress}
      type={variant === 'primary' ? 'solid' : 'outline'}
      color="primary"
      disabled={disabled}
      buttonStyle={buttonStyle}
    />
  );
};

export default Button;
```

#### 2. Импорты

- Импортируйте React в начале файла
- Группируйте импорты: React, React Native, React Native Elements, локальные
- Используйте type imports для типов

```typescript
// ✅ ПРАВИЛЬНО - группировка импортов
import React from 'react';
import { ViewStyle, TextStyle } from 'react-native';
import { Button, Input, Card } from '@rneui/themed';
import { Ionicons } from '@expo/vector-icons';

import type { ButtonProps } from '../../types';
import { useCoffeeFlowTheme } from '../../shared/theme';
import { useColors } from '../../shared/hooks/useColors';

// ❌ НЕПРАВИЛЬНО - хаотичные импорты
import { useColors } from '../../shared/hooks/useColors';
import React from 'react';
import { Button } from '@rneui/themed';
```

### Типизация компонентов

#### 1. Интерфейсы пропсов

- Создавайте интерфейсы для всех пропсов компонента
- Используйте описательные имена для интерфейсов
- Делайте необязательные пропсы с помощью `?`
- Устанавливайте значения по умолчанию для необязательных пропсов

```typescript
// ✅ ПРАВИЛЬНО - четкая типизация
interface InputFieldProps {
  label: string;
  value: string;
  onChangeText: (text: string) => void;
  placeholder?: string;
  error?: string;
  disabled?: boolean;
}

// ❌ НЕПРАВИЛЬНО - слабая типизация
interface InputFieldProps {
  label: any;
  value: any;
  onChangeText: any;
}
```

#### 2. Типизация событий

- Используйте правильные типы для событий
- Типизируйте callback функции

```typescript
// ✅ ПРАВИЛЬНО - типизированные события
interface FormProps {
  onSubmit: (data: FormData) => void;
  onCancel: () => void;
  onChange: (field: keyof FormData, value: string) => void;
}

// ❌ НЕПРАВИЛЬНО - слабая типизация событий
interface FormProps {
  onSubmit: any;
  onCancel: any;
  onChange: any;
}
```

### Стилизация компонентов

#### 1. Использование цветовой системы

- ВСЕГДА используйте цвета из палитры Colors.ts
- Используйте хук `useCoffeeFlowTheme()` для темизации
- Не используйте хардкодные цвета

```typescript
// ✅ ПРАВИЛЬНО - использование цветовой системы
const Button: React.FC<ButtonProps> = ({ variant = 'primary' }) => {
  const { theme } = useCoffeeFlowTheme();
  const colors = useColors();

  const buttonStyle = {
    backgroundColor:
      variant === 'primary' ? colors.primary.main : colors.secondary.main,
    borderColor: colors.borders.primary,
  };

  return (
    <Button
      type={variant === 'primary' ? 'solid' : 'outline'}
      color="primary"
      buttonStyle={buttonStyle}
    />
  );
};

// ❌ НЕПРАВИЛЬНО - хардкодные цвета
const buttonStyle = {
  backgroundColor: '#E08D3C',
  borderColor: '#333',
};
```

#### 2. Стили

- Используйте StyleSheet для создания стилей
- Группируйте связанные стили
- Используйте семантические имена для стилей
- Применяйте стили через props React Native Elements

```typescript
// ✅ ПРАВИЛЬНО - организованные стили
const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
  },
  button: {
    marginTop: 16,
  },
});

// Использование в компоненте
<Button
  title="Нажми меня"
  buttonStyle={styles.button}
  containerStyle={styles.container}
/>

// ❌ НЕПРАВИЛЬНО - инлайн стили
<Button title="Нажми меня" style={{ marginTop: 16, padding: 16 }} />
```

### Логика компонентов

#### 1. Хуки

- Используйте хуки для управления состоянием и побочными эффектами
- Создавайте кастомные хуки для сложной логики
- Разделяйте логику и представление

```typescript
// ✅ ПРАВИЛЬНО - использование хуков
const FormComponent: React.FC<FormProps> = ({ onSubmit }) => {
  const [formData, setFormData] = useState<FormData>({});
  const [errors, setErrors] = useState<FormErrors>({});

  const handleSubmit = useCallback(() => {
    if (validateForm(formData)) {
      onSubmit(formData);
    }
  }, [formData, onSubmit]);

  return (
    <Card>
      <Input
        label="Имя"
        value={formData.name}
        onChangeText={(text) =>
          setFormData((prev) => ({ ...prev, name: text }))
        }
        errorMessage={errors.name}
      />
      <Button title="Отправить" onPress={handleSubmit} />
    </Card>
  );
};

// ❌ НЕПРАВИЛЬНО - смешивание логики и представления
const FormComponent: React.FC<FormProps> = ({ onSubmit }) => {
  // вся логика в компоненте
};
```

#### 2. Обработка событий

- Создавайте отдельные функции для обработки событий
- Используйте useCallback для оптимизации
- Обрабатывайте ошибки и edge cases

```typescript
// ✅ ПРАВИЛЬНО - обработка событий
const handlePress = useCallback(() => {
  try {
    onPress();
  } catch (error) {
    console.error('Button press error:', error);
    // обработка ошибки
  }
}, [onPress]);

// ❌ НЕПРАВИЛЬНО - прямая передача
<Button onPress={onPress} />;
```

### Переиспользование компонентов

#### 1. Пропсы для настройки

- Используйте пропсы для настройки поведения компонента
- Предоставляйте разумные значения по умолчанию
- Используйте variant пропсы для разных стилей

```typescript
// ✅ ПРАВИЛЬНО - настраиваемый компонент
interface ButtonProps {
  variant?: 'primary' | 'secondary' | 'outline';
  size?: 'small' | 'medium' | 'large';
  disabled?: boolean;
  loading?: boolean;
}

const Button: React.FC<ButtonProps> = ({
  variant = 'primary',
  size = 'medium',
  disabled = false,
  loading = false,
  ...props
}) => {
  return (
    <Button
      type={variant === 'outline' ? 'outline' : 'solid'}
      color={variant === 'primary' ? 'primary' : 'secondary'}
      size={size}
      disabled={disabled}
      loading={loading}
      {...props}
    />
  );
};

// ❌ НЕПРАВИЛЬНО - жестко закодированное поведение
const Button: React.FC<ButtonProps> = () => {
  // фиксированное поведение
};
```

#### 2. Композиция

- Используйте children для композиции компонентов
- Создавайте компоненты-контейнеры для сложных макетов

```typescript
// ✅ ПРАВИЛЬНО - композиция через children
const Card: React.FC<{ children: React.ReactNode }> = ({ children }) => (
  <Card containerStyle={styles.card}>{children}</Card>
);

// Использование
<Card>
  <Text>Заголовок</Text>
  <Text>Описание</Text>
</Card>;

// ❌ НЕПРАВИЛЬНО - жестко закодированное содержимое
const Card: React.FC = () => (
  <Card>
    <Text>Заголовок</Text>
    <Text>Описание</Text>
  </Card>
);
```

### Производительность

#### 1. Мемоизация

- Используйте React.memo для компонентов, которые часто перерендериваются
- Используйте useMemo для дорогих вычислений
- Используйте useCallback для функций, передаваемых как пропсы

```typescript
// ✅ ПРАВИЛЬНО - мемоизация
const ExpensiveComponent = React.memo<ComponentProps>(({ data, onPress }) => {
  const processedData = useMemo(() => {
    return processData(data);
  }, [data]);

  const handlePress = useCallback(() => {
    onPress(processedData);
  }, [onPress, processedData]);

  return (
    <Button onPress={handlePress}>
      <Text>{processedData}</Text>
    </Button>
  );
});

// ❌ НЕПРАВИЛЬНО - без мемоизации
const ExpensiveComponent = ({ data, onPress }) => {
  const processedData = processData(data); // пересчитывается при каждом рендере

  return (
    <Button onPress={() => onPress(processedData)}>
      <Text>{processedData}</Text>
    </Button>
  );
};
```

#### 2. Оптимизация рендеринга

- Избегайте создания объектов и функций в render
- Используйте useRef для значений, которые не должны вызывать ререндер
- Разделяйте тяжелые компоненты на более мелкие

### Доступность

#### 1. Accessibility

- Добавляйте accessibilityLabel для интерактивных элементов
- Используйте accessibilityHint для дополнительной информации
- Обеспечивайте навигацию с помощью клавиатуры

```typescript
// ✅ ПРАВИЛЬНО - доступность
<Button
  title="Кнопка входа в систему"
  accessibilityLabel="Кнопка входа в систему"
  accessibilityHint="Нажмите для входа в систему"
  accessibilityRole="button"
  onPress={handlePress}
/>

// ❌ НЕПРАВИЛЬНО - без доступности
<Button onPress={handlePress} />
```

#### 2. Контрастность

- Используйте цвета с достаточным контрастом
- Не полагайтесь только на цвет для передачи информации
- Тестируйте компоненты с различными темами

### Тестирование

#### 1. Структура тестов

- Создавайте тесты для каждого компонента
- Тестируйте различные состояния и пропсы
- Используйте моки для внешних зависимостей

#### 2. Пример теста

```typescript
import { render, fireEvent } from '@testing-library/react-native';
import Button from './Button';

describe('Button', () => {
  it('renders with correct title', () => {
    const { getByText } = render(
      <Button title="Test Button" onPress={jest.fn()} />
    );

    expect(getByText('Test Button')).toBeTruthy();
  });

  it('calls onPress when pressed', () => {
    const onPress = jest.fn();
    const { getByText } = render(
      <Button title="Test Button" onPress={onPress} />
    );

    fireEvent.press(getByText('Test Button'));
    expect(onPress).toHaveBeenCalledTimes(1);
  });
});
```

### Запрещено

- ❌ Создавать компоненты без TypeScript типизации
- ❌ Использовать хардкодные цвета вместо цветовой системы
- ❌ Смешивать логику и представление в одном компоненте
- ❌ Создавать компоненты без обработки ошибок
- ❌ Игнорировать доступность и контрастность
- ❌ Использовать базовые React Native компоненты вместо React Native Elements

### Рекомендуется

- ✅ ВСЕГДА использовать React Native Elements для базовых UI компонентов
- ✅ Использовать функциональные компоненты с хуками
- ✅ Следовать принципу единственной ответственности
- ✅ Создавать переиспользуемые и настраиваемые компоненты
- ✅ Использовать мемоизацию для оптимизации
- ✅ Тестировать все компоненты
- ✅ Обеспечивать доступность
- ✅ Использовать `useCoffeeFlowTheme()` для темизации
- ✅ Размещать экранные компоненты в папке app/ с группировкой по модулям

### React Native Elements компоненты

#### Основные компоненты для использования:

1. **Button** - для всех кнопок
2. **Input** - для текстовых полей
3. **Card** - для карточек и контейнеров
4. **Text** - для текста
5. **SearchBar** - для поиска
6. **Tab** - для навигации
7. **Icon** - для иконок
8. **Divider** - для разделителей
9. **Overlay** - для модальных окон
10. **FAB** - для плавающих кнопок действий

#### Примеры использования:

```typescript
// Кнопка
<Button title="Нажми меня" type="solid" color="primary" />

// Поле ввода
<Input label="Имя" placeholder="Введите имя" />

// Карточка
<Card>
  <Card.Title>Заголовок</Card.Title>
  <Card.Divider />
  <Text>Содержимое</Text>
</Card>

// Поиск
<SearchBar placeholder="Поиск..." />

// Табы
<Tab value={activeTab} onChange={setActiveTab}>
  <Tab.Item title="Первый" value="first" />
  <Tab.Item title="Второй" value="second" />
</Tab>
```

### Экранные компоненты

#### 1. Структура экрана

```typescript
// ✅ ПРАВИЛЬНО - структура экрана
import React from 'react';
import { ScrollView, StyleSheet } from 'react-native';
import { Text, Button } from '@rneui/themed';
import { useCoffeeFlowTheme } from '../../shared/theme';

interface ScreenProps {
  navigation: any; // замените на правильный тип навигации
}

const Screen: React.FC<ScreenProps> = ({ navigation }) => {
  const { theme } = useCoffeeFlowTheme();

  return (
    <ScrollView style={styles.container}>
      <Text h1>Заголовок экрана</Text>
      <Button title="Действие" onPress={() => {}} />
    </ScrollView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
  },
});

export default Screen;
```

#### 2. Навигация между экранами

```typescript
// ✅ ПРАВИЛЬНО - навигация
import { router } from 'expo-router';

const handleNavigation = () => {
  router.navigate('/coffee-shops');
};

// Для параметризованных маршрутов
const handleCoffeeShopPress = (id: string) => {
  router.navigate({
    pathname: '/coffee-shops/[id]',
    params: { id },
  });
};
```

### Заключение

Следуя этим правилам, вы создадите качественные, переиспользуемые и поддерживаемые компоненты для Coffee Flow. **Помните**: ВСЕГДА используйте React Native Elements для базовых UI компонентов и размещайте экранные компоненты в папке `app/` с группировкой по модулям.

- ✅ Использовать мемоизацию для оптимизации
- ✅ Тестировать все компоненты
- ✅ Обеспечивать доступность
