---
description: Работа с api. Интеграция с backend. Запросы к серверу
alwaysApply: false
---

# Coffee Flow API Rules

## Правила для работы с API и интеграцией

### Основные принципы

- **ВСЕГДА создавайте типы для всех API запросов** (body, params, responses)
- **ОБЯЗАТЕЛЬНО обрабатывайте ошибки** и показывайте их пользователю
- **ОБЯЗАТЕЛЬНО показывайте индикаторы загрузки** для всех запросов
- **ОБЯЗАТЕЛЬНО обрабатывайте пустые кейсы** (empty states)
- Используйте централизованную обработку ошибок
- Создавайте переиспользуемые API хуки
- Следуйте принципам REST API и HTTP статус кодов

### Структура API модуля

#### 1. Организация API файлов

```
src/
├── shared/
│   ├── api/
│   │   ├── client.ts              # HTTP клиент (axios/fetch)
│   │   ├── types.ts               # Общие API типы
│   │   ├── errorHandler.ts        # Обработка ошибок
│   │   ├── interceptors.ts        # HTTP интерцепторы
│   │   └── index.ts               # Экспорт API
│   └── hooks/
│       ├── useApi.ts              # Базовый API хук
│       ├── useAsyncOperation.ts   # Хук для асинхронных операций
│       └── index.ts
├── auth/
│   ├── api/
│   │   ├── authApi.ts             # API методы аутентификации
│   │   ├── types.ts               # Типы для auth API
│   │   └── index.ts
│   └── hooks/
│       ├── useAuthApi.ts          # Хуки для auth API
│       └── index.ts
└── coffee-shops/
    ├── api/
    │   ├── coffeeShopsApi.ts      # API методы кофеен
    │   ├── types.ts               # Типы для coffee-shops API
    │   └── index.ts
    └── hooks/
        ├── useCoffeeShopsApi.ts   # Хуки для coffee-shops API
        └── index.ts
```

#### 2. Типизация API запросов

```typescript
// src/shared/api/types.ts
export interface ApiResponse<T> {
  data: T;
  message: string;
  success: boolean;
  timestamp: string;
}

export interface ApiError {
  code: string;
  message: string;
  details?: Record<string, unknown>;
  statusCode: number;
}

export interface PaginationParams {
  page: number;
  limit: number;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
}

export interface PaginatedResponse<T> extends ApiResponse<T[]> {
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
  };
}

// Типы для HTTP методов
export type HttpMethod = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';

export interface RequestConfig {
  method: HttpMethod;
  url: string;
  data?: unknown;
  params?: Record<string, unknown>;
  headers?: Record<string, string>;
}
```

### HTTP клиент и обработка ошибок

#### 1. Настройка HTTP клиента

```typescript
// src/shared/api/client.ts
import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios';
import { ApiResponse, ApiError } from './types';
import { handleApiError } from './errorHandler';

class ApiClient {
  private client: AxiosInstance;

  constructor() {
    this.client = axios.create({
      baseURL: process.env.EXPO_PUBLIC_API_URL || 'https://api.coffeeflow.com',
      timeout: 10000,
      headers: {
        'Content-Type': 'application/json',
      },
    });

    this.setupInterceptors();
  }

  private setupInterceptors() {
    // Request interceptor
    this.client.interceptors.request.use(
      (config) => {
        const token = this.getAuthToken();
        if (token) {
          config.headers.Authorization = `Bearer ${token}`;
        }
        return config;
      },
      (error) => Promise.reject(error)
    );

    // Response interceptor
    this.client.interceptors.response.use(
      (response: AxiosResponse<ApiResponse<unknown>>) => {
        return response;
      },
      (error) => {
        const apiError = handleApiError(error);
        return Promise.reject(apiError);
      }
    );
  }

  private getAuthToken(): string | null {
    // Получение токена из secure storage
    return null; // Заглушка
  }

  async get<T>(
    url: string,
    config?: AxiosRequestConfig
  ): Promise<ApiResponse<T>> {
    const response = await this.client.get<ApiResponse<T>>(url, config);
    return response.data;
  }

  async post<T>(
    url: string,
    data?: unknown,
    config?: AxiosRequestConfig
  ): Promise<ApiResponse<T>> {
    const response = await this.client.post<ApiResponse<T>>(url, data, config);
    return response.data;
  }

  async put<T>(
    url: string,
    data?: unknown,
    config?: AxiosRequestConfig
  ): Promise<ApiResponse<T>> {
    const response = await this.client.put<ApiResponse<T>>(url, data, config);
    return response.data;
  }

  async patch<T>(
    url: string,
    data?: unknown,
    config?: AxiosRequestConfig
  ): Promise<ApiResponse<T>> {
    const response = await this.client.patch<ApiResponse<T>>(url, data, config);
    return response.data;
  }

  async delete<T>(
    url: string,
    config?: AxiosRequestConfig
  ): Promise<ApiResponse<T>> {
    const response = await this.client.delete<ApiResponse<T>>(url, config);
    return response.data;
  }
}

export const apiClient = new ApiClient();
```

#### 2. Обработка ошибок

```typescript
// src/shared/api/errorHandler.ts
import { AxiosError } from 'axios';
import { ApiError } from './types';

export interface ErrorDisplayConfig {
  title: string;
  message: string;
  action?: {
    label: string;
    onPress: () => void;
  };
}

export const handleApiError = (error: AxiosError): ApiError => {
  if (error.response) {
    // Сервер ответил с ошибкой
    const { status, data } = error.response;

    return {
      code: data?.code || 'SERVER_ERROR',
      message: data?.message || 'Произошла ошибка сервера',
      details: data?.details,
      statusCode: status,
    };
  } else if (error.request) {
    // Запрос был отправлен, но ответа не получено
    return {
      code: 'NETWORK_ERROR',
      message: 'Проблема с подключением к интернету',
      statusCode: 0,
    };
  } else {
    // Ошибка при настройке запроса
    return {
      code: 'REQUEST_ERROR',
      message: 'Ошибка при отправке запроса',
      statusCode: 0,
    };
  }
};

export const getErrorDisplayConfig = (error: ApiError): ErrorDisplayConfig => {
  switch (error.code) {
    case 'NETWORK_ERROR':
      return {
        title: 'Нет подключения',
        message: 'Проверьте подключение к интернету и попробуйте снова',
        action: {
          label: 'Повторить',
          onPress: () => {
            // Логика повтора запроса
          },
        },
      };

    case 'INVALID_CREDENTIALS':
      return {
        title: 'Неверные данные',
        message: 'Проверьте правильность введенных данных',
      };

    case 'USER_NOT_FOUND':
      return {
        title: 'Пользователь не найден',
        message: 'Пользователь с такими данными не существует',
      };

    case 'ACCOUNT_LOCKED':
      return {
        title: 'Аккаунт заблокирован',
        message: 'Обратитесь в службу поддержки для разблокировки',
      };

    default:
      return {
        title: 'Ошибка',
        message: error.message || 'Произошла неизвестная ошибка',
        action: {
          label: 'Повторить',
          onPress: () => {
            // Логика повтора запроса
          },
        },
      };
  }
};
```

### API хуки

#### 1. Базовый API хук

```typescript
// src/shared/hooks/useApi.ts
import { useState, useCallback } from 'react';
import { ApiResponse, ApiError } from '../api/types';

interface UseApiState<T> {
  data: T | null;
  loading: boolean;
  error: ApiError | null;
}

interface UseApiReturn<T> extends UseApiState<T> {
  execute: (...args: unknown[]) => Promise<T | null>;
  reset: () => void;
}

export const useApi = <T>(
  apiFunction: (...args: unknown[]) => Promise<ApiResponse<T>>
): UseApiReturn<T> => {
  const [state, setState] = useState<UseApiState<T>>({
    data: null,
    loading: false,
    error: null,
  });

  const execute = useCallback(
    async (...args: unknown[]): Promise<T | null> => {
      setState((prev) => ({ ...prev, loading: true, error: null }));

      try {
        const response = await apiFunction(...args);
        setState({
          data: response.data,
          loading: false,
          error: null,
        });
        return response.data;
      } catch (error) {
        const apiError = error as ApiError;
        setState({
          data: null,
          loading: false,
          error: apiError,
        });
        return null;
      }
    },
    [apiFunction]
  );

  const reset = useCallback(() => {
    setState({
      data: null,
      loading: false,
      error: null,
    });
  }, []);

  return {
    ...state,
    execute,
    reset,
  };
};
```

#### 2. Хук для асинхронных операций

```typescript
// src/shared/hooks/useAsyncOperation.ts
import { useState, useCallback } from 'react';
import { ApiError } from '../api/types';

interface UseAsyncOperationState {
  loading: boolean;
  error: ApiError | null;
  success: boolean;
}

interface UseAsyncOperationReturn extends UseAsyncOperationState {
  execute: (operation: () => Promise<unknown>) => Promise<boolean>;
  reset: () => void;
}

export const useAsyncOperation = (): UseAsyncOperationReturn => {
  const [state, setState] = useState<UseAsyncOperationState>({
    loading: false,
    error: null,
    success: false,
  });

  const execute = useCallback(
    async (operation: () => Promise<unknown>): Promise<boolean> => {
      setState({
        loading: true,
        error: null,
        success: false,
      });

      try {
        await operation();
        setState({
          loading: false,
          error: null,
          success: true,
        });
        return true;
      } catch (error) {
        const apiError = error as ApiError;
        setState({
          loading: false,
          error: apiError,
          success: false,
        });
        return false;
      }
    },
    []
  );

  const reset = useCallback(() => {
    setState({
      loading: false,
      error: null,
      success: false,
    });
  }, []);

  return {
    ...state,
    execute,
    reset,
  };
};
```

### Примеры использования API

#### 1. Auth API

```typescript
// src/auth/api/authApi.ts
import { apiClient } from '../../shared/api/client';
import {
  LoginRequest,
  LoginResponse,
  RegisterRequest,
  RegisterResponse,
  ResetPasswordRequest,
  ResetPasswordResponse,
} from './types';

export const authApi = {
  async login(credentials: LoginRequest): Promise<LoginResponse> {
    const response = await apiClient.post<LoginResponse>(
      '/auth/login',
      credentials
    );
    return response.data;
  },

  async register(userData: RegisterRequest): Promise<RegisterResponse> {
    const response = await apiClient.post<RegisterResponse>(
      '/auth/register',
      userData
    );
    return response.data;
  },

  async resetPassword(
    data: ResetPasswordRequest
  ): Promise<ResetPasswordResponse> {
    const response = await apiClient.post<ResetPasswordResponse>(
      '/auth/reset-password',
      data
    );
    return response.data;
  },

  async refreshToken(refreshToken: string): Promise<LoginResponse> {
    const response = await apiClient.post<LoginResponse>('/auth/refresh', {
      refreshToken,
    });
    return response.data;
  },

  async logout(): Promise<void> {
    await apiClient.post('/auth/logout');
  },
};
```

#### 2. Coffee Shops API

```typescript
// src/coffee-shops/api/coffeeShopsApi.ts
import { apiClient } from '../../shared/api/client';
import {
  CoffeeShopsListRequest,
  CoffeeShopsListResponse,
  CoffeeShopDetailsRequest,
  CoffeeShopDetailsResponse,
} from './types';

export const coffeeShopsApi = {
  async getCoffeeShops(
    params: CoffeeShopsListRequest = {}
  ): Promise<CoffeeShopsListResponse> {
    const response = await apiClient.get<CoffeeShopsListResponse>(
      '/coffee-shops',
      {
        params,
      }
    );
    return response.data;
  },

  async getCoffeeShopDetails(
    params: CoffeeShopDetailsRequest
  ): Promise<CoffeeShopDetailsResponse> {
    const { id, ...queryParams } = params;
    const response = await apiClient.get<CoffeeShopDetailsResponse>(
      `/coffee-shops/${id}`,
      {
        params: queryParams,
      }
    );
    return response.data;
  },

  async searchCoffeeShops(query: string): Promise<CoffeeShopsListResponse> {
    const response = await apiClient.get<CoffeeShopsListResponse>(
      '/coffee-shops/search',
      {
        params: { q: query },
      }
    );
    return response.data;
  },
};
```

### Запрещено

- ❌ Создавать API запросы без типизации
- ❌ Игнорировать обработку ошибок
- ❌ Не показывать индикаторы загрузки
- ❌ Не обрабатывать пустые состояния
- ❌ Использовать `any` для API типов
- ❌ Создавать API хуки без обработки состояний
- ❌ Не использовать централизованную обработку ошибок
- ❌ Игнорировать HTTP статус коды

### Рекомендуется

- ✅ **ВСЕГДА создавать типы для всех API запросов** (body, params, responses)
- ✅ **ОБЯЗАТЕЛЬНО обрабатывать ошибки** и показывать их пользователю
- ✅ **ОБЯЗАТЕЛЬНО показывать индикаторы загрузки** для всех запросов
- ✅ **ОБЯЗАТЕЛЬНО обрабатывать пустые кейсы** (empty states)
- ✅ Использовать централизованную обработку ошибок
- ✅ Создавать переиспользуемые API хуки
- ✅ Следовать принципам REST API
- ✅ Использовать HTTP интерцепторы для общей логики
- ✅ Создавать компоненты для состояний загрузки и ошибок
- ✅ Типизировать все API endpoints и сервисы
- ✅ Использовать discriminated unions для error states
- ✅ Обеспечивать пользователю возможность повторить запрос

### Примеры типизации API

#### 1. Полная типизация запроса

```typescript
// ✅ ПРАВИЛЬНО - полная типизация
interface CreateOrderRequest {
  coffeeShopId: string;
  items: Array<{
    productId: string;
    quantity: number;
    customizations?: Record<string, string>;
  }>;
  deliveryAddress?: {
    street: string;
    building: string;
    apartment?: string;
    entrance?: string;
    floor?: number;
    comment?: string;
  };
  paymentMethod: 'card' | 'cash' | 'online';
  promoCode?: string;
}

interface CreateOrderResponse {
  order: Order;
  estimatedDeliveryTime: string;
  totalAmount: number;
  paymentUrl?: string;
}

const createOrder = async (
  data: CreateOrderRequest
): Promise<CreateOrderResponse> => {
  const response = await apiClient.post<CreateOrderResponse>('/orders', data);
  return response.data;
};

// ❌ НЕПРАВИЛЬНО - без типизации
const createOrder = async (data: any): Promise<any> => {
  const response = await apiClient.post('/orders', data);
  return response.data;
};
```

#### 2. Типизация параметров запроса

```typescript
// ✅ ПРАВИЛЬНО - типизированные параметры
interface GetOrdersParams {
  page?: number;
  limit?: number;
  status?: OrderStatus[];
  dateFrom?: string;
  dateTo?: string;
  sortBy?: 'createdAt' | 'total' | 'status';
  sortOrder?: 'asc' | 'desc';
}

const getOrders = async (
  params: GetOrdersParams = {}
): Promise<PaginatedResponse<Order>> => {
  const response = await apiClient.get<PaginatedResponse<Order>>('/orders', {
    params,
  });
  return response.data;
};

// ❌ НЕПРАВИЛЬНО - нетипизированные параметры
const getOrders = async (params: any = {}): Promise<any> => {
  const response = await apiClient.get('/orders', { params });
  return response.data;
};
```

### Заключение

Следуя этим правилам, вы создадите надежную, типизированную и пользовательски-дружественную систему работы с API. **Помните**: ВСЕГДА создавайте типы для всех API запросов, обрабатывайте ошибки, показывайте индикаторы загрузки и обрабатывайте пустые состояния!

# Coffee Flow API Rules

## Правила для работы с API и интеграцией

### Основные принципы

- **ВСЕГДА создавайте типы для всех API запросов** (body, params, responses)
- **ОБЯЗАТЕЛЬНО обрабатывайте ошибки** и показывайте их пользователю
- **ОБЯЗАТЕЛЬНО показывайте индикаторы загрузки** для всех запросов
- **ОБЯЗАТЕЛЬНО обрабатывайте пустые кейсы** (empty states)
- Используйте централизованную обработку ошибок
- Создавайте переиспользуемые API хуки
- Следуйте принципам REST API и HTTP статус кодов

### Структура API модуля

#### 1. Организация API файлов

```
src/
├── shared/
│   ├── api/
│   │   ├── client.ts              # HTTP клиент (axios/fetch)
│   │   ├── types.ts               # Общие API типы
│   │   ├── errorHandler.ts        # Обработка ошибок
│   │   ├── interceptors.ts        # HTTP интерцепторы
│   │   └── index.ts               # Экспорт API
│   └── hooks/
│       ├── useApi.ts              # Базовый API хук
│       ├── useAsyncOperation.ts   # Хук для асинхронных операций
│       └── index.ts
├── auth/
│   ├── api/
│   │   ├── authApi.ts             # API методы аутентификации
│   │   ├── types.ts               # Типы для auth API
│   │   └── index.ts
│   └── hooks/
│       ├── useAuthApi.ts          # Хуки для auth API
│       └── index.ts
└── coffee-shops/
    ├── api/
    │   ├── coffeeShopsApi.ts      # API методы кофеен
    │   ├── types.ts               # Типы для coffee-shops API
    │   └── index.ts
    └── hooks/
        ├── useCoffeeShopsApi.ts   # Хуки для coffee-shops API
        └── index.ts
```

#### 2. Типизация API запросов

```typescript
// src/shared/api/types.ts
export interface ApiResponse<T> {
  data: T;
  message: string;
  success: boolean;
  timestamp: string;
}

export interface ApiError {
  code: string;
  message: string;
  details?: Record<string, unknown>;
  statusCode: number;
}

export interface PaginationParams {
  page: number;
  limit: number;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
}

export interface PaginatedResponse<T> extends ApiResponse<T[]> {
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
  };
}

// Типы для HTTP методов
export type HttpMethod = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';

export interface RequestConfig {
  method: HttpMethod;
  url: string;
  data?: unknown;
  params?: Record<string, unknown>;
  headers?: Record<string, string>;
}
```

### HTTP клиент и обработка ошибок

#### 1. Настройка HTTP клиента

```typescript
// src/shared/api/client.ts
import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios';
import { ApiResponse, ApiError } from './types';
import { handleApiError } from './errorHandler';

class ApiClient {
  private client: AxiosInstance;

  constructor() {
    this.client = axios.create({
      baseURL: process.env.EXPO_PUBLIC_API_URL || 'https://api.coffeeflow.com',
      timeout: 10000,
      headers: {
        'Content-Type': 'application/json',
      },
    });

    this.setupInterceptors();
  }

  private setupInterceptors() {
    // Request interceptor
    this.client.interceptors.request.use(
      (config) => {
        const token = this.getAuthToken();
        if (token) {
          config.headers.Authorization = `Bearer ${token}`;
        }
        return config;
      },
      (error) => Promise.reject(error)
    );

    // Response interceptor
    this.client.interceptors.response.use(
      (response: AxiosResponse<ApiResponse<unknown>>) => {
        return response;
      },
      (error) => {
        const apiError = handleApiError(error);
        return Promise.reject(apiError);
      }
    );
  }

  private getAuthToken(): string | null {
    // Получение токена из secure storage
    return null; // Заглушка
  }

  async get<T>(
    url: string,
    config?: AxiosRequestConfig
  ): Promise<ApiResponse<T>> {
    const response = await this.client.get<ApiResponse<T>>(url, config);
    return response.data;
  }

  async post<T>(
    url: string,
    data?: unknown,
    config?: AxiosRequestConfig
  ): Promise<ApiResponse<T>> {
    const response = await this.client.post<ApiResponse<T>>(url, data, config);
    return response.data;
  }

  async put<T>(
    url: string,
    data?: unknown,
    config?: AxiosRequestConfig
  ): Promise<ApiResponse<T>> {
    const response = await this.client.put<ApiResponse<T>>(url, data, config);
    return response.data;
  }

  async patch<T>(
    url: string,
    data?: unknown,
    config?: AxiosRequestConfig
  ): Promise<ApiResponse<T>> {
    const response = await this.client.patch<ApiResponse<T>>(url, data, config);
    return response.data;
  }

  async delete<T>(
    url: string,
    config?: AxiosRequestConfig
  ): Promise<ApiResponse<T>> {
    const response = await this.client.delete<ApiResponse<T>>(url, config);
    return response.data;
  }
}

export const apiClient = new ApiClient();
```

#### 2. Обработка ошибок

```typescript
// src/shared/api/errorHandler.ts
import { AxiosError } from 'axios';
import { ApiError } from './types';

export interface ErrorDisplayConfig {
  title: string;
  message: string;
  action?: {
    label: string;
    onPress: () => void;
  };
}

export const handleApiError = (error: AxiosError): ApiError => {
  if (error.response) {
    // Сервер ответил с ошибкой
    const { status, data } = error.response;

    return {
      code: data?.code || 'SERVER_ERROR',
      message: data?.message || 'Произошла ошибка сервера',
      details: data?.details,
      statusCode: status,
    };
  } else if (error.request) {
    // Запрос был отправлен, но ответа не получено
    return {
      code: 'NETWORK_ERROR',
      message: 'Проблема с подключением к интернету',
      statusCode: 0,
    };
  } else {
    // Ошибка при настройке запроса
    return {
      code: 'REQUEST_ERROR',
      message: 'Ошибка при отправке запроса',
      statusCode: 0,
    };
  }
};

export const getErrorDisplayConfig = (error: ApiError): ErrorDisplayConfig => {
  switch (error.code) {
    case 'NETWORK_ERROR':
      return {
        title: 'Нет подключения',
        message: 'Проверьте подключение к интернету и попробуйте снова',
        action: {
          label: 'Повторить',
          onPress: () => {
            // Логика повтора запроса
          },
        },
      };

    case 'INVALID_CREDENTIALS':
      return {
        title: 'Неверные данные',
        message: 'Проверьте правильность введенных данных',
      };

    case 'USER_NOT_FOUND':
      return {
        title: 'Пользователь не найден',
        message: 'Пользователь с такими данными не существует',
      };

    case 'ACCOUNT_LOCKED':
      return {
        title: 'Аккаунт заблокирован',
        message: 'Обратитесь в службу поддержки для разблокировки',
      };

    default:
      return {
        title: 'Ошибка',
        message: error.message || 'Произошла неизвестная ошибка',
        action: {
          label: 'Повторить',
          onPress: () => {
            // Логика повтора запроса
          },
        },
      };
  }
};
```

### API хуки

#### 1. Базовый API хук

```typescript
// src/shared/hooks/useApi.ts
import { useState, useCallback } from 'react';
import { ApiResponse, ApiError } from '../api/types';

interface UseApiState<T> {
  data: T | null;
  loading: boolean;
  error: ApiError | null;
}

interface UseApiReturn<T> extends UseApiState<T> {
  execute: (...args: unknown[]) => Promise<T | null>;
  reset: () => void;
}

export const useApi = <T>(
  apiFunction: (...args: unknown[]) => Promise<ApiResponse<T>>
): UseApiReturn<T> => {
  const [state, setState] = useState<UseApiState<T>>({
    data: null,
    loading: false,
    error: null,
  });

  const execute = useCallback(
    async (...args: unknown[]): Promise<T | null> => {
      setState((prev) => ({ ...prev, loading: true, error: null }));

      try {
        const response = await apiFunction(...args);
        setState({
          data: response.data,
          loading: false,
          error: null,
        });
        return response.data;
      } catch (error) {
        const apiError = error as ApiError;
        setState({
          data: null,
          loading: false,
          error: apiError,
        });
        return null;
      }
    },
    [apiFunction]
  );

  const reset = useCallback(() => {
    setState({
      data: null,
      loading: false,
      error: null,
    });
  }, []);

  return {
    ...state,
    execute,
    reset,
  };
};
```

#### 2. Хук для асинхронных операций

```typescript
// src/shared/hooks/useAsyncOperation.ts
import { useState, useCallback } from 'react';
import { ApiError } from '../api/types';

interface UseAsyncOperationState {
  loading: boolean;
  error: ApiError | null;
  success: boolean;
}

interface UseAsyncOperationReturn extends UseAsyncOperationState {
  execute: (operation: () => Promise<unknown>) => Promise<boolean>;
  reset: () => void;
}

export const useAsyncOperation = (): UseAsyncOperationReturn => {
  const [state, setState] = useState<UseAsyncOperationState>({
    loading: false,
    error: null,
    success: false,
  });

  const execute = useCallback(
    async (operation: () => Promise<unknown>): Promise<boolean> => {
      setState({
        loading: true,
        error: null,
        success: false,
      });

      try {
        await operation();
        setState({
          loading: false,
          error: null,
          success: true,
        });
        return true;
      } catch (error) {
        const apiError = error as ApiError;
        setState({
          loading: false,
          error: apiError,
          success: false,
        });
        return false;
      }
    },
    []
  );

  const reset = useCallback(() => {
    setState({
      loading: false,
      error: null,
      success: false,
    });
  }, []);

  return {
    ...state,
    execute,
    reset,
  };
};
```

### Примеры использования API

#### 1. Auth API

```typescript
// src/auth/api/authApi.ts
import { apiClient } from '../../shared/api/client';
import {
  LoginRequest,
  LoginResponse,
  RegisterRequest,
  RegisterResponse,
  ResetPasswordRequest,
  ResetPasswordResponse,
} from './types';

export const authApi = {
  async login(credentials: LoginRequest): Promise<LoginResponse> {
    const response = await apiClient.post<LoginResponse>(
      '/auth/login',
      credentials
    );
    return response.data;
  },

  async register(userData: RegisterRequest): Promise<RegisterResponse> {
    const response = await apiClient.post<RegisterResponse>(
      '/auth/register',
      userData
    );
    return response.data;
  },

  async resetPassword(
    data: ResetPasswordRequest
  ): Promise<ResetPasswordResponse> {
    const response = await apiClient.post<ResetPasswordResponse>(
      '/auth/reset-password',
      data
    );
    return response.data;
  },

  async refreshToken(refreshToken: string): Promise<LoginResponse> {
    const response = await apiClient.post<LoginResponse>('/auth/refresh', {
      refreshToken,
    });
    return response.data;
  },

  async logout(): Promise<void> {
    await apiClient.post('/auth/logout');
  },
};
```

#### 2. Coffee Shops API

```typescript
// src/coffee-shops/api/coffeeShopsApi.ts
import { apiClient } from '../../shared/api/client';
import {
  CoffeeShopsListRequest,
  CoffeeShopsListResponse,
  CoffeeShopDetailsRequest,
  CoffeeShopDetailsResponse,
} from './types';

export const coffeeShopsApi = {
  async getCoffeeShops(
    params: CoffeeShopsListRequest = {}
  ): Promise<CoffeeShopsListResponse> {
    const response = await apiClient.get<CoffeeShopsListResponse>(
      '/coffee-shops',
      {
        params,
      }
    );
    return response.data;
  },

  async getCoffeeShopDetails(
    params: CoffeeShopDetailsRequest
  ): Promise<CoffeeShopDetailsResponse> {
    const { id, ...queryParams } = params;
    const response = await apiClient.get<CoffeeShopDetailsResponse>(
      `/coffee-shops/${id}`,
      {
        params: queryParams,
      }
    );
    return response.data;
  },

  async searchCoffeeShops(query: string): Promise<CoffeeShopsListResponse> {
    const response = await apiClient.get<CoffeeShopsListResponse>(
      '/coffee-shops/search',
      {
        params: { q: query },
      }
    );
    return response.data;
  },
};
```

### Запрещено

- ❌ Создавать API запросы без типизации
- ❌ Игнорировать обработку ошибок
- ❌ Не показывать индикаторы загрузки
- ❌ Не обрабатывать пустые состояния
- ❌ Использовать `any` для API типов
- ❌ Создавать API хуки без обработки состояний
- ❌ Не использовать централизованную обработку ошибок
- ❌ Игнорировать HTTP статус коды

### Рекомендуется

- ✅ **ВСЕГДА создавать типы для всех API запросов** (body, params, responses)
- ✅ **ОБЯЗАТЕЛЬНО обрабатывать ошибки** и показывать их пользователю
- ✅ **ОБЯЗАТЕЛЬНО показывать индикаторы загрузки** для всех запросов
- ✅ **ОБЯЗАТЕЛЬНО обрабатывать пустые кейсы** (empty states)
- ✅ Использовать централизованную обработку ошибок
- ✅ Создавать переиспользуемые API хуки
- ✅ Следовать принципам REST API
- ✅ Использовать HTTP интерцепторы для общей логики
- ✅ Создавать компоненты для состояний загрузки и ошибок
- ✅ Типизировать все API endpoints и сервисы
- ✅ Использовать discriminated unions для error states
- ✅ Обеспечивать пользователю возможность повторить запрос

### Примеры типизации API

#### 1. Полная типизация запроса

```typescript
// ✅ ПРАВИЛЬНО - полная типизация
interface CreateOrderRequest {
  coffeeShopId: string;
  items: Array<{
    productId: string;
    quantity: number;
    customizations?: Record<string, string>;
  }>;
  deliveryAddress?: {
    street: string;
    building: string;
    apartment?: string;
    entrance?: string;
    floor?: number;
    comment?: string;
  };
  paymentMethod: 'card' | 'cash' | 'online';
  promoCode?: string;
}

interface CreateOrderResponse {
  order: Order;
  estimatedDeliveryTime: string;
  totalAmount: number;
  paymentUrl?: string;
}

const createOrder = async (
  data: CreateOrderRequest
): Promise<CreateOrderResponse> => {
  const response = await apiClient.post<CreateOrderResponse>('/orders', data);
  return response.data;
};

// ❌ НЕПРАВИЛЬНО - без типизации
const createOrder = async (data: any): Promise<any> => {
  const response = await apiClient.post('/orders', data);
  return response.data;
};
```

#### 2. Типизация параметров запроса

```typescript
// ✅ ПРАВИЛЬНО - типизированные параметры
interface GetOrdersParams {
  page?: number;
  limit?: number;
  status?: OrderStatus[];
  dateFrom?: string;
  dateTo?: string;
  sortBy?: 'createdAt' | 'total' | 'status';
  sortOrder?: 'asc' | 'desc';
}

const getOrders = async (
  params: GetOrdersParams = {}
): Promise<PaginatedResponse<Order>> => {
  const response = await apiClient.get<PaginatedResponse<Order>>('/orders', {
    params,
  });
  return response.data;
};

// ❌ НЕПРАВИЛЬНО - нетипизированные параметры
const getOrders = async (params: any = {}): Promise<any> => {
  const response = await apiClient.get('/orders', { params });
  return response.data;
};
```

### Заключение

Следуя этим правилам, вы создадите надежную, типизированную и пользовательски-дружественную систему работы с API. **Помните**: ВСЕГДА создавайте типы для всех API запросов, обрабатывайте ошибки, показывайте индикаторы загрузки и обрабатывайте пустые состояния!
