---
description: Создание или редактирование хуков
alwaysApply: false
---

# Coffee Flow Hooks Rules

## Правила для React хуков

### Основные принципы

- Хуки должны следовать правилам хуков React
- Используйте TypeScript для типизации возвращаемых значений и параметров
- Хуки должны быть переиспользуемыми и независимыми от конкретных компонентов
- Разделяйте логику на простые, специализированные хуки

### Структура хука

#### 1. Стандартная структура

```typescript
import { useState, useEffect, useCallback, useMemo } from 'react';
import type { HookReturnType, HookParams } from '../../types';

interface UseAuthParams {
  initialPhoneNumber?: string;
  onSuccess?: (data: AuthData) => void;
  onError?: (error: string) => void;
}

interface UseAuthReturn {
  phoneNumber: string;
  password: string;
  isLoading: boolean;
  error: string | null;
  setPhoneNumber: (phone: string) => void;
  setPassword: (pass: string) => void;
  handleLogin: () => Promise<void>;
  handleRegistration: () => Promise<void>;
}

const useAuth = ({
  initialPhoneNumber = '',
  onSuccess,
  onError,
}: UseAuthParams = {}): UseAuthReturn => {
  // Состояние хука
  const [phoneNumber, setPhoneNumber] = useState(initialPhoneNumber);
  const [password, setPassword] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // Логика хука

  // Возвращаемые значения
  return {
    phoneNumber,
    password,
    isLoading,
    error,
    setPhoneNumber,
    setPassword,
    handleLogin,
    handleRegistration,
  };
};

export default useAuth;
```

#### 2. Импорты

- Группируйте импорты: React хуки, типы, утилиты, сервисы
- Используйте type imports для типов
- Импортируйте только необходимые хуки

```typescript
// ✅ ПРАВИЛЬНО - группировка импортов
import { useState, useEffect, useCallback, useMemo } from 'react';
import { Alert } from 'react-native';

import type { AuthData, AuthError } from '../../types';
import { authService } from '../../services/authService';
import { validatePhoneNumber } from '../../utils/validation';

// ❌ НЕПРАВИЛЬНО - хаотичные импорты
import { validatePhoneNumber } from '../../utils/validation';
import { useState } from 'react';
import type { AuthData } from '../../types';
```

### Типизация хуков

#### 1. Интерфейсы параметров

- Создавайте интерфейсы для всех параметров хука
- Используйте описательные имена для интерфейсов
- Делайте необязательные параметры с помощью `?`
- Устанавливайте значения по умолчанию для необязательных параметров

```typescript
// ✅ ПРАВИЛЬНО - четкая типизация параметров
interface UseFormParams<T> {
  initialValues: T;
  validationSchema?: ValidationSchema<T>;
  onSubmit: (data: T) => Promise<void>;
  onError?: (errors: ValidationErrors<T>) => void;
}

// ❌ НЕПРАВИЛЬНО - слабая типизация
interface UseFormParams {
  initialValues: any;
  validationSchema?: any;
  onSubmit: any;
  onError?: any;
}
```

#### 2. Интерфейсы возвращаемых значений

- Создавайте интерфейсы для всех возвращаемых значений
- Используйте описательные имена для методов
- Типизируйте все callback функции

```typescript
// ✅ ПРАВИЛЬНО - типизированные возвращаемые значения
interface UseFormReturn<T> {
  values: T;
  errors: ValidationErrors<T>;
  isValid: boolean;
  isLoading: boolean;
  setValue: (field: keyof T, value: T[keyof T]) => void;
  setValues: (values: Partial<T>) => void;
  handleSubmit: () => Promise<void>;
  reset: () => void;
}

// ❌ НЕПРАВИЛЬНО - слабая типизация
interface UseFormReturn {
  values: any;
  errors: any;
  setValue: any;
  handleSubmit: any;
}
```

### Логика хуков

#### 1. Управление состоянием

- Используйте useState для локального состояния хука
- Группируйте связанное состояние в объекты
- Используйте useReducer для сложного состояния

```typescript
// ✅ ПРАВИЛЬНО - группировка связанного состояния
const useForm = <T>(initialValues: T) => {
  const [state, setState] = useState({
    values: initialValues,
    errors: {} as ValidationErrors<T>,
    isValid: true,
    isLoading: false,
  });

  const setValue = useCallback((field: keyof T, value: T[keyof T]) => {
    setState((prev) => ({
      ...prev,
      values: { ...prev.values, [field]: value },
    }));
  }, []);

  return { ...state, setValue };
};

// ❌ НЕПРАВИЛЬНО - разрозненное состояние
const useForm = <T>(initialValues: T) => {
  const [values, setValues] = useState(initialValues);
  const [errors, setErrors] = useState({});
  const [isValid, setIsValid] = useState(true);
  const [isLoading, setIsLoading] = useState(false);
  // сложно управлять состоянием
};
```

#### 2. Побочные эффекты

- Используйте useEffect для побочных эффектов
- Разделяйте эффекты по ответственности
- Используйте cleanup функции для очистки ресурсов

```typescript
// ✅ ПРАВИЛЬНО - разделение эффектов
const useAuth = (phoneNumber: string) => {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(false);

  // Эффект для загрузки пользователя
  useEffect(() => {
    if (!phoneNumber) return;

    const loadUser = async () => {
      setIsLoading(true);
      try {
        const userData = await authService.getUser(phoneNumber);
        setUser(userData);
      } catch (error) {
        console.error('Failed to load user:', error);
      } finally {
        setIsLoading(false);
      }
    };

    loadUser();
  }, [phoneNumber]);

  // Эффект для подписки на изменения
  useEffect(() => {
    if (!user) return;

    const unsubscribe = authService.subscribeToUser(user.id, setUser);
    return unsubscribe;
  }, [user?.id]);

  return { user, isLoading };
};

// ❌ НЕПРАВИЛЬНО - смешивание эффектов
const useAuth = (phoneNumber: string) => {
  useEffect(() => {
    // загрузка пользователя и подписка в одном эффекте
    if (phoneNumber) {
      loadUser();
      subscribeToUser();
    }
  }, [phoneNumber]);
};
```

#### 3. Оптимизация

- Используйте useCallback для функций, передаваемых как пропсы
- Используйте useMemo для дорогих вычислений
- Избегайте создания новых объектов в каждом рендере

```typescript
// ✅ ПРАВИЛЬНО - оптимизация с useCallback и useMemo
const useForm = <T>(
  initialValues: T,
  validationSchema?: ValidationSchema<T>
) => {
  const [values, setValues] = useState(initialValues);
  const [errors, setErrors] = useState({});

  // Мемоизация валидации
  const isValid = useMemo(() => {
    if (!validationSchema) return true;
    return validationSchema.isValid(values);
  }, [values, validationSchema]);

  // Мемоизация обработчиков
  const setValue = useCallback((field: keyof T, value: T[keyof T]) => {
    setValues((prev) => ({ ...prev, [field]: value }));
  }, []);

  const handleSubmit = useCallback(async () => {
    if (!isValid) return;
    // логика отправки
  }, [isValid]);

  return { values, errors, isValid, setValue, handleSubmit };
};

// ❌ НЕПРАВИЛЬНО - без оптимизации
const useForm = <T>(
  initialValues: T,
  validationSchema?: ValidationSchema<T>
) => {
  const [values, setValues] = useState(initialValues);
  const [errors, setErrors] = useState({});

  // Валидация пересчитывается при каждом рендере
  const isValid = validationSchema ? validationSchema.isValid(values) : true;

  // Новые функции создаются при каждом рендере
  const setValue = (field: keyof T, value: T[keyof T]) => {
    setValues((prev) => ({ ...prev, [field]: value }));
  };

  return { values, errors, isValid, setValue };
};
```

### Обработка ошибок

#### 1. Try-catch блоки

- Обрабатывайте ошибки в async функциях
- Предоставляйте понятные сообщения об ошибках
- Логируйте ошибки для отладки

```typescript
// ✅ ПРАВИЛЬНО - обработка ошибок
const useApiCall = <T>(apiFunction: () => Promise<T>) => {
  const [data, setData] = useState<T | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);

  const execute = useCallback(async () => {
    setIsLoading(true);
    setError(null);

    try {
      const result = await apiFunction();
      setData(result);
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Unknown error';
      setError(errorMessage);
      console.error('API call failed:', err);
    } finally {
      setIsLoading(false);
    }
  }, [apiFunction]);

  return { data, error, isLoading, execute };
};

// ❌ НЕПРАВИЛЬНО - без обработки ошибок
const useApiCall = <T>(apiFunction: () => Promise<T>) => {
  const [data, setData] = useState<T | null>(null);
  const [isLoading, setIsLoading] = useState(false);

  const execute = async () => {
    setIsLoading(true);
    const result = await apiFunction(); // может упасть
    setData(result);
    setIsLoading(false);
  };

  return { data, isLoading, execute };
};
```

#### 2. Валидация входных данных

- Валидируйте параметры хука
- Предоставляйте значения по умолчанию
- Обрабатывайте edge cases

```typescript
// ✅ ПРАВИЛЬНО - валидация входных данных
const useLocalStorage = <T>(key: string, initialValue: T) => {
  // Валидация параметров
  if (!key || typeof key !== 'string') {
    throw new Error('useLocalStorage: key must be a non-empty string');
  }

  const [storedValue, setStoredValue] = useState<T>(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error('Failed to parse stored value:', error);
      return initialValue;
    }
  });

  // ... остальная логика
};

// ❌ НЕПРАВИЛЬНО - без валидации
const useLocalStorage = <T>(key: string, initialValue: T) => {
  const [storedValue, setStoredValue] = useState<T>(() => {
    const item = window.localStorage.getItem(key); // может быть null
    return JSON.parse(item); // может упасть
  });
};
```

### Переиспользование хуков

#### 1. Композиция хуков

- Создавайте простые, специализированные хуки
- Комбинируйте их в более сложные хуки
- Избегайте дублирования логики

```typescript
// ✅ ПРАВИЛЬНО - композиция хуков
const useForm = <T>(
  initialValues: T,
  validationSchema?: ValidationSchema<T>
) => {
  const { values, setValue, setValues } = useFormState(initialValues);
  const { errors, validate, isValid } = useValidation(values, validationSchema);
  const { isLoading, execute: submit } = useApiCall(() =>
    formService.submit(values)
  );

  const handleSubmit = useCallback(async () => {
    if (!isValid) return;
    await submit();
  }, [isValid, submit]);

  return {
    values,
    errors,
    isValid,
    isLoading,
    setValue,
    setValues,
    handleSubmit,
  };
};

// ❌ НЕПРАВИЛЬНО - дублирование логики
const useForm = <T>(
  initialValues: T,
  validationSchema?: ValidationSchema<T>
) => {
  // вся логика в одном хуке
  const [values, setValues] = useState(initialValues);
  const [errors, setErrors] = useState({});
  const [isLoading, setIsLoading] = useState(false);
  // ... много дублированной логики
};
```

#### 2. Параметризация

- Используйте параметры для настройки поведения хука
- Предоставляйте разумные значения по умолчанию
- Используйте объекты для множественных параметров

```typescript
// ✅ ПРАВИЛЬНО - параметризация хука
interface UseDebounceParams {
  delay?: number;
  immediate?: boolean;
  maxWait?: number;
}

const useDebounce = <T>(
  value: T,
  { delay = 300, immediate = false, maxWait }: UseDebounceParams = {}
) => {
  // логика хука с настраиваемыми параметрами
};

// Использование
const debouncedValue = useDebounce(searchTerm, { delay: 500, immediate: true });

// ❌ НЕПРАВИЛЬНО - жестко закодированные параметры
const useDebounce = <T>(value: T) => {
  // фиксированная задержка 300ms
};
```

### Тестирование хуков

#### 1. Структура тестов

- Создавайте тесты для каждого хука
- Тестируйте различные параметры и состояния
- Используйте моки для внешних зависимостей

#### 2. Пример теста

```typescript
import { renderHook, act } from '@testing-library/react-hooks';
import useForm from './useForm';

describe('useForm', () => {
  it('initializes with initial values', () => {
    const initialValues = { name: '', email: '' };
    const { result } = renderHook(() => useForm(initialValues));

    expect(result.current.values).toEqual(initialValues);
    expect(result.current.isValid).toBe(true);
  });

  it('updates values when setValue is called', () => {
    const { result } = renderHook(() => useForm({ name: '', email: '' }));

    act(() => {
      result.current.setValue('name', 'John');
    });

    expect(result.current.values.name).toBe('John');
  });

  it('calls onSubmit when form is valid', async () => {
    const onSubmit = jest.fn();
    const { result } = renderHook(() =>
      useForm({ name: 'John', email: 'john@example.com' }, onSubmit)
    );

    await act(async () => {
      await result.current.handleSubmit();
    });

    expect(onSubmit).toHaveBeenCalledWith({
      name: 'John',
      email: 'john@example.com',
    });
  });
});
```

### Запрещено

- ❌ Создавать хуки без TypeScript типизации
- ❌ Нарушать правила хуков React
- ❌ Создавать хуки с побочными эффектами без cleanup
- ❌ Игнорировать обработку ошибок
- ❌ Создавать хуки, зависящие от конкретных компонентов

### Рекомендуется

- ✅ Следовать правилам хуков React
- ✅ Использовать TypeScript для типизации
- ✅ Разделять логику на простые, специализированные хуки
- ✅ Обрабатывать ошибки и edge cases
- ✅ Оптимизировать производительность с useCallback и useMemo
- ✅ Тестировать все хуки
- ✅ Документировать API хука
